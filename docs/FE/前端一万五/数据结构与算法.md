--- 
title: 前端一万五 - 数据结构与算法篇
date: 2020-01-19
sidebar: 'auto'
categories: 
 - 前端一万五
tags: 
 - 算法
publish: true
---

<!-- more -->

## 开始

### 基础算法

1. 字符串

- 反转字符串中的单词
- 计算二进制子串

2. 数组

- 电话号码的组合
- 卡牌分组
- 种花问题
- 格雷编码

3. 正则表达式

- 重复的子字符串
- 正则表达式匹配

4. 排序

- 冒泡排序
- 选择排序
- 按基偶排序数组
- 数组中的第K个最大元素
- 最大间距
- 缺失的第一个正数

5. 递归

- 复原ip地址
- 与所有单词相关联的字符串

### 数据结构

1. 堆栈

- 根据字符出现频率排序
- 超级丑数
- 棒球比赛
- 最大矩阵

2. 队列

- 设计循环队列
- 任务调度器

3. 链表

- 排序链表
- 环形链表

4. 矩阵

- 螺旋矩阵
- 旋转图像

5. 二叉树

- 对称二叉树
- 验证二叉树

### 进阶算法

1. 贪心算法

- 买卖股票的最佳时机
- 柠檬水找零

2. 动态规划

- 不同路径
- K站中转内最便宜的航班

## 字符串

### 例题

1. [557] 反转字符串中的单词 III

```js
/*
 * https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/description/
 *
 * Testcase Example:  `"Let's take LeetCode contest"`
 *
 * 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
 *
 * 示例 1:
 *
 *
 * 输入: "Let's take LeetCode contest"
 * 输出: "s'teL ekat edoCteeL tsetnoc"
 *
 *
 * 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
 *
 */
```

```js
/**
 * 解法一
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.split(' ')
    .map(word => (word.split('').reverse().join('')))
    .join(' ')
}
```

```js
/**
 * 解法二
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.split(/\s/g)
    .reduce((str, word) => (str + ' ' + word.split('').reverse().join('')), '')
    .substring(1)
}
```

```js
/**
 * 解法三
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.match(/[\w']+/ig)
    .reduce((str, word) => (str + ' ' + word.split('').reverse().join('')), '')
    .substring(1)
}
```

2. [696] 计数二进制子串

```js
/*
 * https://leetcode-cn.com/problems/count-binary-substrings/description/
 *
 * 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
 *
 * 重复出现的子串要计算它们出现的次数。
 *
 * 示例 1 :
 *
 *
 * 输入: "00110011"
 * 输出: 6
 * 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
 *
 * 请注意，一些重复出现的子串要计算它们出现的次数。
 *
 * 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
 *
 *
 * 示例 2 :
 *
 *
 * 输入: "10101"
 * 输出: 4
 * 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
 *
 *
 * 注意：
 * s.length 在1到50,000之间。
 * s 只包含“0”或“1”字符。
 *
 */
```

```js
/**
 * @param {string} s
 * @return {number}
 */
var countBinarySubstrings = function(s) {
  const r = []
  const match = (str) => {
    const j = str.match(/^(0+|1+)/)[0] // 连续0或1
    // 逻辑位运算符：位与（&）、位或（|）、位异或（^）、非位（~）
    // 移位运算符：左移（<<）、右移（>>）、无符号右移（>>>）
    // ^ => 相同取0，相异取1
    const o = (j[0] ^ 1).toString().repeat(j.length)
    const reg = new RegExp(`^(${j}${o})`)
    if (reg.test(str)) {
      return RegExp.$1
    } else {
      return ''
    }
  }
  for (let i = 0, len = s.length - 1; i < len; i++) {
    const sub = match(s.slice(i))
    if (sub) {
      r.push(sub)
    }
  }
  return r.length
}
```

### 知识点

- String.prototype.split

- String.prototype.match

- String.prototype.substring

- String.prototype.slice

- Array.prototype.map

- Array.prototype.reverse

- Array.prototype.join

- Array.prototype.reduce

- Array.prototype.repeat

## 数组

### 例题

1. [17] 电话号码的字母组合 (公式运算)

```js
/*
 * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/
 *
 * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
 *
 * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 *
 * 示例:
 *
 * 输入："23"
 * 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
 *
 *
 * 说明:
 * 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
 *
 */
```

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  // 1. 建立数字和字母的映射
  const map = new Map([
    [2, 'abc'],
    [3, 'def'],
    [4, 'ghi'],
    [5, 'jkl'],
    [6, 'mno'],
    [7, 'pqrs'],
    [8, 'tuv'],
    [9, 'wxyz']
  ])
  // 2. 把输入的字符串分割成数组 234 => [2, 3, 4]
  const nums = digits.split('').map(str => Number(str))
  // 3. 整数型数组转键盘字母映射数组 [2, 3, 4] => ['abc', 'def', 'ghi]
  const strs = nums.map(num => (map.get(num)))

  const combinations = function(arr) {
    const tmp = []
    for (const wordA of (arr[0] ? arr[0] : [])) {
      for (const wordB of (arr[1] ? arr[1] : [''])) {
        tmp.push(`${wordA}${wordB}`)
      }
    }
    arr.splice(0, 2, tmp) // 删除前两项，在开头增加tmp数组作为0项
    if (arr.length === 1) {
      return arr[0]
    }
    return combinations([...arr])
  }
  return combinations([...strs])
}
```

2. [914] 卡牌分组 (归类运算)

```js
/*
 * https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/description/
 *
 * 给定一副牌，每张牌上都写着一个整数。
 *
 * 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
 *
 *
 * 每组都有 X 张牌。
 * 组内所有的牌上都写着相同的整数。
 *
 *
 * 仅当你可选的 X >= 2 时返回 true。
 *
 *
 * 示例 1：
 *
 * 输入：[1,2,3,4,4,3,2,1]
 * 输出：true
 * 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
 *
 * 示例 2：
 *
 * 输入：[1,1,1,2,2,2,3,3]
 * 输出：false
 * 解释：没有满足要求的分组。
 *
 * 示例 3：
 *
 * 输入：[1]
 * 输出：false
 * 解释：没有满足要求的分组。
 *
 * 示例 4：
 *
 * 输入：[1,1]
 * 输出：true
 * 解释：可行的分组是 [1,1]
 *
 * 示例 5：
 *
 * 输入：[1,1,2,2,2,2]
 * 输出：true
 * 解释：可行的分组是 [1,1]，[2,2]，[2,2]
 *
 * 提示：
 * 1 <= deck.length <= 10000
 * 0 <= deck[i] < 10000
 */
```

```js
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  const group = []
  const tmp = {}

  // 统计每一个数字出现的次数 => 对象用来计次很方便哦, key: value
  deck.forEach(item => {
    tmp[item] = tmp[item] ? tmp[item] + 1 : 1
  })

  // group用于存放每张牌的总数
  for (const v of Object.values(tmp)) {
    group.push(v)
  }

  // 求两个数的最大公约数
  const gcd = (a, b) => {
    if (b === 0) {
      return a
    } else {
      return gcd(b, a % b)
    }
  }

  while (group.length > 1) {
    const a = group.shift() // 取第一个数字的次数
    const b = group.shift() // 取第二个数字的次数
    const v = gcd(a, b) // 取两个数字的最大公约数
    if (v === 1) {
      return false
    } else {
      group.unshift(v)
    }
  }
  return group.length ? group[0] > 1 : false
}
```

3. [605] 种花问题 (筛选运算)

```js
/*
 * https://leetcode-cn.com/problems/can-place-flowers/description/
 *
 * 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
 *
 * 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n
 * 朵花？能则返回True，不能则返回False。
 *
 * 示例 1:
 *
 *
 * 输入: flowerbed = [1,0,0,0,1], n = 1
 * 输出: True
 *
 *
 * 示例 2:
 *
 *
 * 输入: flowerbed = [1,0,0,0,1], n = 2
 * 输出: False
 *
 *
 * 注意:
 *
 * 数组内已种好的花不会违反种植规则。
 * 输入的数组长度范围为 [1, 20000]。
 * n 是非负整数，且不会超过输入数组的大小。
 */
```

```js
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  let max = 0
  for (let i = 0, len = flowerbed.length - 1; i <= len; i++) {
    if (flowerbed[i] === 0) {
      if ((i === 0 && flowerbed[1] === 0) || // 第一个没有种花， 且第一个也没有种花
        (i === 0 && len === 0) || // 第一个没有种花，且只有一个花位
        (i === len && flowerbed[len - 1] === 0) // 最后一个没有种花， 且倒数第二个没有种花
      ) {
        max++
        i++ // i++ 用于排除当前种花了的位置
      } else if (flowerbed[i - 1] === 0 && flowerbed[i + 1] === 0) { // 不是第一个和最后一个位置的边界情况，且前一个和后一个都没有种花
        max++
        i++
      }
    }
  }
  return max >= n
}
```

4. [89] 格雷编码 (二进制运算)

```js
/*
 * https://leetcode-cn.com/problems/gray-code/description/
 * 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
 *
 * 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。
 *
 * 示例 1:
 *
 * 输入: 2
 * 输出: [0,1,3,2]
 * 解释:
 * 00 - 0
 * 01 - 1
 * 11 - 3
 * 10 - 2
 *
 * 对于给定的 n，其格雷编码序列并不唯一。
 * 例如，[0,2,3,1] 也是一个有效的格雷编码序列。
 *
 * 00 - 0
 * 10 - 2
 * 11 - 3
 * 01 - 1
 *
 * 示例 2:
 *
 * 输入: 0
 * 输出: [0]
 * 解释: 我们定义格雷编码序列必须以 0 开头。
 * 给定编码总位数为 n 的格雷编码序列，其长度为 2^n。当 n = 0 时，长度为 2^0 = 1。
 * 因此，当 n = 0 时，其格雷编码序列为 [0]。
 */
```

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
  const make = function(m) {
    if (m === 1) {
      return ['0', '1']
    } else if (m === 0) {
      return ['0']
    }
    const prev = make(m - 1) // 递归
    const len = Math.pow(2, m)
    const res = []
    for (let i = 0; i < len / 2; i++) {
      res[i] = `0${prev[i]}`
      res[len - i - 1] = `1${prev[i]}`
    }
    return res
  }
  // 二进制转十进制
  return make(n).map(binary => (parseInt(binary, 2)))
}
```

```js
// 进制转换
parseInt(num, 8) // 八进制转十进制
parseInt(num, 16) // 十六进制转十进制
parseInt(num).toString(8) // 十进制转八进制
parseInt(num).toString(16) // 十进制转十六进制
parseInt(num, 2).toString(8) // 二进制转八进制
parseInt(num, 2).toString(16) // 二进制转十六进制
parseInt(num, 8).toString(2) // 八进制转二进制
parseInt(num, 8).toString(16) // 八进制转十六进制
parseInt(num, 16).toString(2) // 十六进制转二进制
parseInt(num, 16).toString(8) // 十六进制转八进制
```

### 知识点

- Array.prototype.splice
- Array.prototype.shift
- Array.prototype.unshift

## 正则

### 例题

1. [459] 重复的子字符串

```js
/*
 * https://leetcode-cn.com/problems/repeated-substring-pattern/description/
 *
 * 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。
 *
 * 示例 1:
 *
 *
 * 输入: "abab"
 *
 * 输出: True
 *
 * 解释: 可由子字符串 "ab" 重复两次构成。
 *
 *
 * 示例 2:
 *
 *
 * 输入: "aba"
 *
 * 输出: False
 *
 *
 * 示例 3:
 *
 *
 * 输入: "abcabcabcabc"
 *
 * 输出: True
 *
 * 解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)
 *
 *
 */
```

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
  const re = /^(\w+)\1+$/g
  return re.test(s)
}
```

### 知识点

- [MDN正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
- [前端一万五-正则篇](http://i7xy.cn/FE/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%B8%87%E4%BA%94/%E6%AD%A3%E5%88%99%E7%AF%87.html#%E7%9B%B8%E5%85%B3api-%E9%87%8D%E7%82%B9)

## 排序

### 例题

1. 冒泡排序

最大值一直往右边走 ~ (泡越来越大)

```js
const mpSort = ([...arr]) => {
  for (let i = arr.length, tmp; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      tmp = arr[j]
      if (tmp > arr[j + 1]) {
        arr[j] = arr[j + 1]
        arr[j + 1] = tmp
      }
    }
  }
  return arr
}
```

2. 选择排序

循环一遍找到最小的，移到左边还没排序的位置

```js
const selectSort = ([...arr]) => {
  for (let i = 0, len = arr.length, minIndex; i < len; i++) {
    minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[minIndex] > arr[j]) { minIndex = j }
    }
    const c = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = c
  }
  return arr
}
```

3. 最大间距

```js
/*
 * @lc app=leetcode.cn id=164 lang=javascript
 *
 * [164] 最大间距
 *
 * https://leetcode-cn.com/problems/maximum-gap/description/
 *
 * algorithms
 * Hard (52.83%)
 * Likes:    132
 * Dislikes: 0
 * Total Accepted:    12.8K
 * Total Submissions: 23.3K
 * Testcase Example:  '[3,6,9,1]'
 *
 * 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。
 *
 * 如果数组元素个数小于 2，则返回 0。
 *
 * 示例 1:
 *
 * 输入: [3,6,9,1]
 * 输出: 3
 * 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
 *
 * 示例 2:
 *
 * 输入: [10]
 * 输出: 0
 * 解释: 数组元素个数小于 2，因此返回 0。
 *
 * 说明:
 *
 *
 * 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
 * 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。
 *
 *
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function(nums) {
  if (nums.length < 2) { return 0 }
  let max = 0
  nums.sort((a, b) => (a - b))
  for (let i = 0; i < nums.length - 1; i++) {
    const c = nums[i + 1] - nums[i]
    if (max < c) { max = c }
  }
  return max
}
// @lc code=end

console.log('log => : maximumGap([1, 2, 3, 10])', maximumGap([1, 2, 3, 10]))

```

```js
// 冒泡排序版
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumGap = function(nums) {
  let max = 0
  if (nums.length < 2) { return max }
  for (let i = nums.length, tmp; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      if (nums[j + 1] < nums[j]) {
        tmp = nums[j + 1]
        nums[j + 1] = nums[j]
        nums[j] = tmp
      }
    }
    const c = nums[i] - nums[i - 1]
    if (max < c) {
      max = c
    }
  }
  return max
}
```

4. 按基数和偶数排序数组

```js
/*
 * @lc app=leetcode.cn id=922 lang=javascript
 *
 * [922] 按奇偶排序数组 II
 *
 * https://leetcode-cn.com/problems/sort-array-by-parity-ii/description/
 *
 * algorithms
 * Easy (66.58%)
 * Likes:    84
 * Dislikes: 0
 * Total Accepted:    26.3K
 * Total Submissions: 39.2K
 * Testcase Example:  '[4,2,5,7]'
 *
 * 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
 *
 * 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
 *
 * 你可以返回任何满足上述条件的数组作为答案。
 *
 *
 *
 * 示例：
 *
 * 输入：[4,2,5,7]
 * 输出：[4,5,2,7]
 * 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= A.length <= 20000
 * A.length % 2 == 0
 * 0 <= A[i] <= 1000
 *
 *
 *
 *
 */

// @lc code=start
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParityII = function(A) {
  A.sort()
  const arr = []
  for (let i = 0, oddIndex = 1, evenIndex = 0; i < A.length; i++) {
    if (A[i] % 2 === 0) {
      arr[evenIndex] = A[i]
      evenIndex += 2
    } else {
      arr[oddIndex] = A[i]
      oddIndex += 2
    }
  }
  return arr
}
// @lc code=end

console.log('log => : sortArrayByParityII([4, 2, 5, 7])', sortArrayByParityII([4, 2, 5, 7]))

```

5. 数组中的第K个最大元素

```js
/*
 * @lc app=leetcode.cn id=215 lang=javascript
 *
 * [215] 数组中的第K个最大元素
 *
 * https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/
 *
 * algorithms
 * Medium (60.36%)
 * Likes:    424
 * Dislikes: 0
 * Total Accepted:    101.7K
 * Total Submissions: 164.4K
 * Testcase Example:  '[3,2,1,5,6,4]\n2'
 *
 * 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
 *
 * 示例 1:
 *
 * 输入: [3,2,1,5,6,4] 和 k = 2
 * 输出: 5
 *
 *
 * 示例 2:
 *
 * 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
 * 输出: 4
 *
 * 说明:
 *
 * 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
 *
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  return nums.sort((a, b) => b - a)[k - 1]
}
// @lc code=end

console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6, 7, 7, 8, 2, 3, 1, 1, 1, 10, 11, 5, 6, 2, 4, 7, 8, 5, 6], 2))

```

```js
// 冒泡排序版
// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  for (let i = nums.length, tmp; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      if (nums[j + 1] < nums[j]) {
        tmp = nums[j + 1]
        nums[j + 1] = nums[j]
        nums[j] = tmp
      }
    }
    if (nums.length - i === k - 1) {
      return nums[i - 1]
    }
  }
  return 0
}
// @lc code=end

console.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4))

```

6. 缺失的第一个正数

```js
/*
 * @lc app=leetcode.cn id=41 lang=javascript
 *
 * [41] 缺失的第一个正数
 *
 * https://leetcode-cn.com/problems/first-missing-positive/description/
 *
 * algorithms
 * Hard (37.27%)
 * Likes:    457
 * Dislikes: 0
 * Total Accepted:    44.8K
 * Total Submissions: 118.2K
 * Testcase Example:  '[1,2,0]'
 *
 * 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
 *
 *
 *
 * 示例 1:
 *
 * 输入: [1,2,0]
 * 输出: 3
 *
 *
 * 示例 2:
 *
 * 输入: [3,4,-1,1]
 * 输出: 2
 *
 *
 * 示例 3:
 *
 * 输入: [7,8,9,11,12]
 * 输出: 1
 *
 *
 *
 *
 * 提示：
 *
 * 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。
 *
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  nums = nums.filter(num => num > 0)
  nums.sort((a, b) => a - b) // 可以优化，没必要全部进行排序，边排边找答案就行
  if (!nums.length || nums[0] !== 1) {
    return 1
  }
  for (let i = 0; i < nums.length - 1; i++) {
    if (nums[i + 1] - nums[i] > 1) {
      return nums[i] + 1
    }
  }
    // return nums[nums.length - 1] + 1 // 等同于↓
  return nums.pop() + 1
}
// @lc code=end

console.log(firstMissingPositive([-1, 4, 2, 1, 9, 10]))

```

```js
// 冒泡排序版
// @lc code=start
/**
 * @param {number[]} nums
 * @return {number}
 */
var firstMissingPositive = function(nums) {
  nums = nums.filter(num => num > 0)
  if (nums.length === 0) { return 1 }
  for (let i = nums.length, tmp; i > 0; i--) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[j + 1]) {
        tmp = nums[j]
        nums[j] = nums[j + 1]
        nums[j + 1] = tmp
      }
    }
    if (i !== nums.length) {
      if (nums[i - 1] - nums[i] > 1) {
        return nums[i] + 1
      }
    } else {
      if (nums[i - 1] !== 1) { // 最后一位，最小的不是1， 直接返回1
        return 1
      }
    }
  }
  return nums.shift() + 1 // 排序完了还没满足，取最大的+1
}
```

7. 快速排序

把一个数组一分为二，取出中间的数字，遍历数组的每一项与这个中间值进行比较，大的放右边，小的放左边，然后递归左右数组直到数组长度为1：

```js
// 二分法
const quickSort = (arr) => {
  if (arr.length < 1) return arr
  const midValue = arr.splice(Math.floor(arr.length / 2), 1)[0]
  const left = []
  const right = []
  arr.forEach((item) => {
    item > midValue ? right.push(item) : left.push(item)
  })
  return [...quickSort(left), midValue, ...quickSort(right)]
}

// 原地快排
var quickSort=function(arr,left,right){

  // 如果左边界比右边界大，返回结果，排序结束
  if(left>right){
    return;
  }

  // 默认值处理，如果有传入left和right参数，就赋值这个参数，否则就赋值后面的默认值
  left=left||0;
  right=right||arr.length-1;

  // 定义移动的左游标和右游标
  var leftPoint=left;
  var rightPoint=right;

  // 定义一个基准数
  var temp=arr[left];

  // 判断左右游标是否重合，如果重合，循环结束
  while(leftPoint!==rightPoint){

    // 基准数在左边，因此从右边开始一个个扫描
    // 从右到左，寻找小于基准数的数，且左游标要小于右游标
    // 如果数字大于基准数（证明不符合条件），寻找下一个
    // 直到找到比基准数小的数，游标停止递减
    while(arr[rightPoint]>=temp&&leftPoint<rightPoint){
      rightPoint--;
    }
    // 从左到右，寻找大于基准数的数，且左游标要小于右游标
    // 如果数字小于基准数（证明不符合条件），寻找下一个
    // 直到找到比基准数小的数，游标停止递增
    while(arr[leftPoint]<=temp&&leftPoint<rightPoint){
      leftPoint++;
    }

    // 如果左游标小于右游标，则交换两个数字的位置
    if(leftPoint<rightPoint){
      var changeNumber=arr[leftPoint];
      arr[leftPoint]=arr[rightPoint];
      arr[rightPoint]=changeNumber;
    }
    // 进行下一次循环，直到两个游标重合位置
  }

  // 重合之后，交换基准数
  arr[left]=arr[leftPoint];
  arr[leftPoint]=temp;

  // 递归操作左右两个数组
  quickSort(arr,left,leftPoint-1);
  quickSort(arr,leftPoint+1,right);

  return arr;
};
var numArr=[6,1,2,7,9,4,5,10,8];
console.log(quickSort(numArr));
```

### 知识点

1. [时间复杂度](https://www.cnblogs.com/yuqing6/p/10785440.html)

- 假设每行代码执行一次的时间设为t，代码的总执行时间为T(n)。

```js
function factorial(){
    let i = 0 // 执行了1次
    let re = 1 // 执行了1次
    for(;i < n; i++ ){ // 执行了n次
        re*= n // 执行了n次
    }
    return re // 执行了1次
}
```

> T(n) = 2t + 2nt + t = (2n ＋ 3)t

- 大O表示法表示代码执行时间随数据规模增长的变化趋势

> T(n) = O(2n + 3)

- 大O表示法表示代码执行时间随数据规模增长的变化趋势，忽略系数和常数

> T(n) = O(n)

  - 不保留系数
  - 只保留最高阶
  - 嵌套代码的复杂度内外代码复杂度的乘积

```md
如何快速分析一段代码的时间复杂度：我们上面总结出了大O表示法的特点，只保留最高阶，所以在分析代码的时间复杂度时，我们只需要关心代码执行次数最多的代码，其他的都可以忽略。

最常见的时间复杂度有常数阶O(1),对数阶O(logn),线性阶O(n),线性对数阶O(nlogn),平方阶O(n²)

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2)
```

2. 空间复杂度

空间复杂度是一般是O(1) ，递归算法的空间复杂度为o(n)，具体的...

> 并且只能使用常数级别的额外空间，不能有递归...

3. Array.prototype.sort

- arr.sort()，不写参数，按照编码排序，比如1,10,2...

- arr.sort((a, b) => a - b), 小 -> 大

- arr.sort((a, b) => a - b), 大 -> 小

## 递归

### 例题

1. 复原IP地址

```js
/*
 * @lc app=leetcode.cn id=93 lang=javascript
 *
 * [93] 复原IP地址
 *
 * https://leetcode-cn.com/problems/restore-ip-addresses/description/
 *
 * algorithms
 * Medium (45.33%)
 * Likes:    229
 * Dislikes: 0
 * Total Accepted:    35K
 * Total Submissions: 75.5K
 * Testcase Example:  '"25525511135"'
 *
 * 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
 *
 * 示例:
 *
 * 输入: "25525511135"
 * 输出: ["255.255.11.135", "255.255.111.35"]
 *
 */

// @lc code=start
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(str) {
  // 保存所有符合条件的IP地址
  const r = []
  // 分四步递归处理ip分段
  const search = (cur, sub) => {
    if (str.length > 12) { return }
    if (cur.length === 4 && cur.join('') === str) {
      r.push(cur.join('.'))
    }
    const min = Math.min(sub.length, 3)
    for (let i = 0; i < min; i++) {
      const s = sub.substr(0, i + 1)
      if (s - 256 < 0) {
        search(cur.concat([s * 1]), sub.substr(i + 1))
      }
    }
  }
  search([], str)
  return r
}
// @lc code=end

```
