--- 
title: 前端一万五 - 数据结构与算法篇
date: 2020-01-19
sidebar: 'auto'
categories: 
 - 前端一万五
tags: 
 - 算法
publish: true
---

<!-- more -->

## 开始

### 基础算法

1. 字符串

- 反转字符串中的单词
- 计算二进制子串

2. 数组

- 电话号码的组合
- 卡牌分组
- 种花问题
- 格雷编码

3. 正则表达式

- 重复的子字符串
- 正则表达式匹配

4. 排序

- 冒泡排序
- 选择排序
- 按基偶排序数组
- 数组中的第K个最大元素
- 最大间距
- 缺失的第一个正数

5. 递归

- 复原ip地址
- 与所有单词相关联的字符串

### 数据结构

1. 堆栈

- 根据字符出现频率排序
- 超级丑数
- 棒球比赛
- 最大矩阵

2. 队列

- 设计循环队列
- 任务调度器

3. 链表

- 排序链表
- 环形链表

4. 矩阵

- 螺旋矩阵
- 旋转图像

5. 二叉树

- 对称二叉树
- 验证二叉树

### 进阶算法

1. 贪心算法

- 买卖股票的最佳时机
- 柠檬水找零

2. 动态规划

- 不同路径
- K站中转内最便宜的航班

## 字符串

### 例题

1. [557] 反转字符串中的单词 III

```js
/*
 * https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/description/
 *
 * Testcase Example:  `"Let's take LeetCode contest"`
 *
 * 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
 *
 * 示例 1:
 *
 *
 * 输入: "Let's take LeetCode contest"
 * 输出: "s'teL ekat edoCteeL tsetnoc"
 *
 *
 * 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。
 *
 */
```

```js
/**
 * 解法一
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.split(' ')
    .map(word => (word.split('').reverse().join('')))
    .join(' ')
}
```

```js
/**
 * 解法二
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.split(/\s/g)
    .reduce((str, word) => (str + ' ' + word.split('').reverse().join('')), '')
    .substring(1)
}
```

```js
/**
 * 解法三
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
  return s.match(/[\w']+/ig)
    .reduce((str, word) => (str + ' ' + word.split('').reverse().join('')), '')
    .substring(1)
}
```

2. [696] 计数二进制子串

```js
/*
 * https://leetcode-cn.com/problems/count-binary-substrings/description/
 *
 * 给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
 *
 * 重复出现的子串要计算它们出现的次数。
 *
 * 示例 1 :
 *
 *
 * 输入: "00110011"
 * 输出: 6
 * 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
 *
 * 请注意，一些重复出现的子串要计算它们出现的次数。
 *
 * 另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
 *
 *
 * 示例 2 :
 *
 *
 * 输入: "10101"
 * 输出: 4
 * 解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
 *
 *
 * 注意：
 * s.length 在1到50,000之间。
 * s 只包含“0”或“1”字符。
 *
 */
```

```js
/**
 * @param {string} s
 * @return {number}
 */
var countBinarySubstrings = function(s) {
  const r = []
  const match = (str) => {
    const j = str.match(/^(0+|1+)/)[0] // 连续0或1
    // 逻辑位运算符：位与（&）、位或（|）、位异或（^）、非位（~）
    // 移位运算符：左移（<<）、右移（>>）、无符号右移（>>>）
    // ^ => 相同取0，相异取1
    const o = (j[0] ^ 1).toString().repeat(j.length)
    const reg = new RegExp(`^(${j}${o})`)
    if (reg.test(str)) {
      return RegExp.$1
    } else {
      return ''
    }
  }
  for (let i = 0, len = s.length - 1; i < len; i++) {
    const sub = match(s.slice(i))
    if (sub) {
      r.push(sub)
    }
  }
  return r.length
}
```

### 知识点

- String.prototype.split

- String.prototype.match

- String.prototype.substring

- String.prototype.slice

- Array.prototype.map

- Array.prototype.reverse

- Array.prototype.join

- Array.prototype.reduce

- Array.prototype.repeat

## 数组

### 例题

1. [17] 电话号码的字母组合 (公式运算)

```js
/*
 * https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/
 *
 * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。
 *
 * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
 *
 * 示例:
 *
 * 输入："23"
 * 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
 *
 *
 * 说明:
 * 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。
 *
 */
```

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
  // 1. 建立数字和字母的映射
  const map = new Map([
    [2, 'abc'],
    [3, 'def'],
    [4, 'ghi'],
    [5, 'jkl'],
    [6, 'mno'],
    [7, 'pqrs'],
    [8, 'tuv'],
    [9, 'wxyz']
  ])
  // 2. 把输入的字符串分割成数组 234 => [2, 3, 4]
  const nums = digits.split('').map(str => Number(str))
  // 3. 整数型数组转键盘字母映射数组 [2, 3, 4] => ['abc', 'def', 'ghi]
  const strs = nums.map(num => (map.get(num)))

  const combinations = function(arr) {
    const tmp = []
    for (const wordA of (arr[0] ? arr[0] : [])) {
      for (const wordB of (arr[1] ? arr[1] : [''])) {
        tmp.push(`${wordA}${wordB}`)
      }
    }
    arr.splice(0, 2, tmp) // 删除前两项，在开头增加tmp数组作为0项
    if (arr.length === 1) {
      return arr[0]
    }
    return combinations([...arr])
  }
  return combinations([...strs])
}
```

2. [914] 卡牌分组 (归类运算)

```js
/*
 * https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/description/
 *
 * 给定一副牌，每张牌上都写着一个整数。
 *
 * 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：
 *
 *
 * 每组都有 X 张牌。
 * 组内所有的牌上都写着相同的整数。
 *
 *
 * 仅当你可选的 X >= 2 时返回 true。
 *
 *
 * 示例 1：
 *
 * 输入：[1,2,3,4,4,3,2,1]
 * 输出：true
 * 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]
 *
 * 示例 2：
 *
 * 输入：[1,1,1,2,2,2,3,3]
 * 输出：false
 * 解释：没有满足要求的分组。
 *
 * 示例 3：
 *
 * 输入：[1]
 * 输出：false
 * 解释：没有满足要求的分组。
 *
 * 示例 4：
 *
 * 输入：[1,1]
 * 输出：true
 * 解释：可行的分组是 [1,1]
 *
 * 示例 5：
 *
 * 输入：[1,1,2,2,2,2]
 * 输出：true
 * 解释：可行的分组是 [1,1]，[2,2]，[2,2]
 *
 * 提示：
 * 1 <= deck.length <= 10000
 * 0 <= deck[i] < 10000
 */
```

```js
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
  const group = []
  const tmp = {}

  // 统计每一个数字出现的次数 => 对象用来计次很方便哦, key: value
  deck.forEach(item => {
    tmp[item] = tmp[item] ? tmp[item] + 1 : 1
  })

  // group用于存放每张牌的总数
  for (const v of Object.values(tmp)) {
    group.push(v)
  }

  // 求两个数的最大公约数
  const gcd = (a, b) => {
    if (b === 0) {
      return a
    } else {
      return gcd(b, a % b)
    }
  }

  while (group.length > 1) {
    const a = group.shift() // 取第一个数字的次数
    const b = group.shift() // 取第二个数字的次数
    const v = gcd(a, b) // 取两个数字的最大公约数
    if (v === 1) {
      return false
    } else {
      group.unshift(v)
    }
  }
  return group.length ? group[0] > 1 : false
}
```

3. [605] 种花问题 (筛选运算)

```js
/*
 * https://leetcode-cn.com/problems/can-place-flowers/description/
 *
 * 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
 *
 * 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n
 * 朵花？能则返回True，不能则返回False。
 *
 * 示例 1:
 *
 *
 * 输入: flowerbed = [1,0,0,0,1], n = 1
 * 输出: True
 *
 *
 * 示例 2:
 *
 *
 * 输入: flowerbed = [1,0,0,0,1], n = 2
 * 输出: False
 *
 *
 * 注意:
 *
 * 数组内已种好的花不会违反种植规则。
 * 输入的数组长度范围为 [1, 20000]。
 * n 是非负整数，且不会超过输入数组的大小。
 */
```

```js
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
  let max = 0
  for (let i = 0, len = flowerbed.length - 1; i <= len; i++) {
    if (flowerbed[i] === 0) {
      if ((i === 0 && flowerbed[1] === 0) || // 第一个没有种花， 且第一个也没有种花
        (i === 0 && len === 0) || // 第一个没有种花，且只有一个花位
        (i === len && flowerbed[len - 1] === 0) // 最后一个没有种花， 且倒数第二个没有种花
      ) {
        max++
        i++ // i++ 用于排除当前种花了的位置
      } else if (flowerbed[i - 1] === 0 && flowerbed[i + 1] === 0) { // 不是第一个和最后一个位置的边界情况，且前一个和后一个都没有种花
        max++
        i++
      }
    }
  }
  return max >= n
}
```

4. [89] 格雷编码 (二进制运算)

```js
/*
 * https://leetcode-cn.com/problems/gray-code/description/
 * 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
 *
 * 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。
 *
 * 示例 1:
 *
 * 输入: 2
 * 输出: [0,1,3,2]
 * 解释:
 * 00 - 0
 * 01 - 1
 * 11 - 3
 * 10 - 2
 *
 * 对于给定的 n，其格雷编码序列并不唯一。
 * 例如，[0,2,3,1] 也是一个有效的格雷编码序列。
 *
 * 00 - 0
 * 10 - 2
 * 11 - 3
 * 01 - 1
 *
 * 示例 2:
 *
 * 输入: 0
 * 输出: [0]
 * 解释: 我们定义格雷编码序列必须以 0 开头。
 * 给定编码总位数为 n 的格雷编码序列，其长度为 2^n。当 n = 0 时，长度为 2^0 = 1。
 * 因此，当 n = 0 时，其格雷编码序列为 [0]。
 */
```

```js
/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
  const make = function(m) {
    if (m === 1) {
      return ['0', '1']
    } else if (m === 0) {
      return ['0']
    }
    const prev = make(m - 1) // 递归
    const len = Math.pow(2, m)
    const res = []
    for (let i = 0; i < len / 2; i++) {
      res[i] = `0${prev[i]}`
      res[len - i - 1] = `1${prev[i]}`
    }
    return res
  }
  // 二进制转十进制
  return make(n).map(binary => (parseInt(binary, 2)))
}
```

```js
// 进制转换
parseInt(num, 8) // 八进制转十进制
parseInt(num, 16) // 十六进制转十进制
parseInt(num).toString(8) // 十进制转八进制
parseInt(num).toString(16) // 十进制转十六进制
parseInt(num, 2).toString(8) // 二进制转八进制
parseInt(num, 2).toString(16) // 二进制转十六进制
parseInt(num, 8).toString(2) // 八进制转二进制
parseInt(num, 8).toString(16) // 八进制转十六进制
parseInt(num, 16).toString(2) // 十六进制转二进制
parseInt(num, 16).toString(8) // 十六进制转八进制
```

### 知识点

- Array.prototype.splice
- Array.prototype.shift
- Array.prototype.unshift

## 正则

### 例题

1. [459] 重复的子字符串

```js
/*
 * https://leetcode-cn.com/problems/repeated-substring-pattern/description/
 *
 * 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。
 *
 * 示例 1:
 *
 *
 * 输入: "abab"
 *
 * 输出: True
 *
 * 解释: 可由子字符串 "ab" 重复两次构成。
 *
 *
 * 示例 2:
 *
 *
 * 输入: "aba"
 *
 * 输出: False
 *
 *
 * 示例 3:
 *
 *
 * 输入: "abcabcabcabc"
 *
 * 输出: True
 *
 * 解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)
 *
 *
 */
```

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
  const re = /^(\w+)\1+$/g
  return re.test(s)
}
```

### 知识点

- [MDN正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)
- [前端一万五-正则篇](http://i7xy.cn/FE/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%B8%87%E4%BA%94/%E6%AD%A3%E5%88%99%E7%AF%87.html#%E7%9B%B8%E5%85%B3api-%E9%87%8D%E7%82%B9)

## 排序

### 例题

### 知识点

1. [时间复杂度](https://www.cnblogs.com/yuqing6/p/10785440.html)
2. [空间复杂度]()
